let[@libRty] chdir ?l:(a = (true : [%v: Path.t])) =
  {
    pre = _G (Any true);
    res = (true : [%v: unit]);
    newadding = lastL && Chdir ((a [@d]), v, true);
  }

let[@libRty] ioctl ?l:(a = (true : [%v: Path.t])) ?l:(c = (true : [%v: int])) =
  {
    pre = canWriteP a;
    res = (true : [%v: unit]);
    newadding = lastL && Ioctl ((a [@d]), (c [@d]), v, true);
  }

let[@libRty] openFile ?l:(a = (true : [%v: Path.t])) ?l:(c = (true : [%v: int]))
    =
  [|
    {
      pre = isOpened a;
      res = (v : [%v: bool]);
      newadding = lastL && OpenFile ((a [@d]), (c [@d]), v, v);
    };
    {
      pre = not (isOpened a);
      res = (not v : [%v: bool]);
      newadding = lastL && OpenFile ((a [@d]), (c [@d]), v, not v);
    };
  |]

let[@libRty] closeFile ?l:(a = (true : [%v: Path.t])) =
  {
    pre = isOpened a;
    res = (true : [%v: bool]);
    newadding = lastL && CloseFile ((a [@d]), v, true);
  }

let[@libRty] fread ?l:(a = (true : [%v: Path.t])) ?l:(b = (v > 0 : [%v: int])) =
  {
    pre = canReadP a;
    res = (true : [%v: Bytes.t]);
    newadding = lastL && Fread ((a [@d]), (b [@d]), v, true);
  }

let[@libRty] fseek ?l:(a = (true : [%v: Path.t])) ?l:(b = (true : [%v: int])) =
  {
    pre = isOpened a;
    res = (true : [%v: unit]);
    newadding = lastL && Fseek ((a [@d]), (b [@d]), v, true);
  }

let[@libRty] fwrite ?l:(a = (true : [%v: Path.t]))
    ?l:(b = (true : [%v: Bytes.t])) =
  {
    pre = canWriteP a;
    res = (true : [%v: unit]);
    newadding = lastL && Fwrite ((a [@d]), (b [@d]), v, true);
  }

let[@libRty] rename ?l:(a = (true : [%v: Path.t]))
    ?l:(b = (true : [%v: Path.t])) =
  {
    pre = not (isOpened a);
    res = (true : [%v: unit]);
    newadding = lastL && Rename ((a [@d]), (b [@d]), v, true);
  }

let[@libRty] append ?l:(a = (true : [%v: Path.t]))
    ?l:(b = (true : [%v: Path.t])) : [%v: Path.t] =
  (is_babuk_renamed b) #==> (is_babuk_renamed v)

let[@libRty] babuk_postfix ?l:(a = (true : [%v: unit])) : [%v: Path.t] =
  is_babuk_renamed v

let[@libRty] encrypt ?l:(a = (true : [%v: Bytes.t])) : [%v: Bytes.t] = true

let[@libRty] whoami ?l:(a = (true : [%v: unit])) =
  {
    pre = _G (Any true);
    res = (true : [%v: User.t]);
    newadding = lastL && Whoami (x, v, true);
  }

let[@libRty] curl ?l:(a = (true : [%v: Link.t])) ?l:(b = (true : [%v: Path.t]))
    =
  {
    pre = _G (Any true);
    res = (true : [%v: unit]);
    newadding = lastL && Curl ((a [@d]), (b [@d]), v, true);
  }

let[@libRty] chmod ?l:(a = (true : [%v: int])) ?l:(b = (true : [%v: Path.t])) =
  {
    pre = _G (Any true);
    res = (true : [%v: unit]);
    newadding = lastL && Chmod ((a [@d]), (b [@d]), v, true);
  }

let[@libRty] bash ?l:(a = (true : [%v: Path.t])) ?l:(b = (true : [%v: unit])) =
  { pre = _G (Any true); res = (true : [%v: unit]); newadding = _G (Any true) }

let[@libRty] nohup
    ?l:(thunk =
        fun ?l:(b = (true : [%v: unit])) ->
          {
            pre = _G (Any true);
            res = (true : [%v: unit]);
            post = _G (Any true);
          }) ?l:(a = (true : [%v: Path.t])) =
  {
    pre = _G (Any true);
    res = (true : [%v: unit]);
    newadding =
      (Nohup (x, (a [@d]), v, true);
       _G (Any true));
  }

let[@libRty] is_root_user ?l:(a = (true : [%v: User.t])) : [%v: bool] = true

let[@libRty] cron_link ?l:(a = (true : [%v: unit])) : [%v: Link.t] =
  is_cron_link v

let[@libRty] daemon_path ?l:(a = (true : [%v: unit])) : [%v: Path.t] =
  is_daemon_path v

let[@libRty] tmp_dir ?l:(a = (true : [%v: unit])) : [%v: Path.t] = is_tmp_dir v

let[@libRty] mining_script_link ?l:(a = (true : [%v: unit])) : [%v: Link.t] =
  is_mining_script_link v

let[@libRty] null_dir ?l:(a = (true : [%v: unit])) : [%v: Path.t] =
  is_null_dir v
